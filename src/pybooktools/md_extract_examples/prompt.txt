I need a python function `extract_examples` that extracts all the fenced examples in a markdown file
that contain a "slug line," which is a commented first line in the fenced example containing
the name of that file. Each example should be placed in its own file in the target directory.

The root directory for the target directory will be provided as an argument to the `extract_examples`.
The markdown file to extract the examples from will also be an argument.

The target directory for the markdown file is created from the markdown file name. In the following
example, the markdown file name is:
`04 Basic_Annotations.md`
The target directory is created by removing the `.md`. lowercasing the name, and replacing spaces with underscores:
`04_basic_annotations`

Here's the contents of an example Markdown file:

# Basic Annotations

> This placeholder text was generated by ChatGPT 4.5.
> It will be significantly rewritten as the book is developed.
> In the meantime you can add comments to either <https://bsky.app/bruceeckel> or [Github Issues](https://github.com/ThinkingInTypes/ThinkingInTypes.github.io/issues).

## Annotating Built-in Types (`int`, `str`, `float`, `bool`, `None`)

Python supports type annotations for its fundamental built-in types, allowing developers to clarify expected types of variables and function arguments explicitly:

```python
# example_1.py
age: int = 25
name: str = "Alice"
salary: float = 45000.50
is_active: bool = True
no_value: None = None
```

These annotations immediately communicate intent, simplifying code readability and maintainability.

## Annotating Variables and Functions

Type annotations can be added to variables and function parameters to indicate expected data types:

### Variables

```python
# example_2.py
user_id: int = 123
username: str = "admin"
```

### Functions

```python
# example_3.py
def greet_user(username: str) -> str:
    return f"Welcome, {username}!"
```

Annotations clearly specify expected input and output types, helping prevent bugs and errors.

## Optional Types and Default Values

Sometimes a variable or function argument can be a specific type or `None`.
Python uses `Optional` from `typing` to indicate this:

```python
# example_4.py
from typing import Optional

def find_user(user_id: int) -> Optional[str]:
    if user_id == 1:
        return "Alice"
    return None
```

Default values with optional annotations:

```python
# example_5.py
def greet(name: Optional[str] = None) -> str:
    if name:
        return f"Hello, {name}!"
    return "Hello!"
```

## Using Union Types (`|` operator vs. `Union`)

Python allows you to specify multiple acceptable types for variables or parameters.
Traditionally, the `Union` type was used, but Python 3.10 introduced the `|` operator for readability:

### Using `Union`

```python
# example_6.py
from typing import Union

def process_value(value: Union[int, str]) -> str:
    return str(value)
```

### Using `|` operator (Python 3.10+)

```python
# example_7.py
def process_value(value: int | str) -> str:
    return str(value)
```

The `|` operator provides clearer and more concise syntax.

## Defining Type Aliases

Type aliases simplify complex annotations by providing a readable and reusable name for a type:

```python
# example_8.py
from typing import List

UserIDs = List[int]

def process_users(user_ids: UserIDs) -> None:
    for uid in user_ids:
        print(f"Processing user {uid}")
```

Aliases improve code clarity, especially for complex types.

## Common Annotation Patterns and Errors

### Common Patterns

- Clearly annotate function parameters and return values.
- Use type aliases for complex or repetitive types.
- Use optional annotations when values can legitimately be `None`.

### Common Errors

- Incorrect annotations (e.g., annotating as `int` when the value might be `float`).
- Missing annotations on important public APIs or interfaces.
- Overuse of overly broad types like `Any`, reducing annotation benefits.

Example error:

```python
# example_9.py
def calculate_area(radius: int) -> float:
    return 3.14 * radius ** 2

calculate_area(3.5)  # Error detected by static type checkers
```

Careful use of annotations combined with static checking tools significantly enhances code robustness and readability.
